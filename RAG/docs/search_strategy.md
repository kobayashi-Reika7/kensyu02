# 検索戦略 - OnsenRAG 3段階パイプライン

## 概要

OnsenRAGでは、3段階の検索パイプラインで高精度な文書選定を行います。

```
質問「草津のカフェは？」
       ↓
  温泉地フィルタ（"草津" → location=kusatsu に絞り込み）
       ↓
  Step 1: ハイブリッド検索 + CrossEncoderスコアリング
       ↓
  Step 2: LLM候補抽出（上位5件）
       ↓
  Step 3: 最終選択（スコア統合 → 上位3件）
       ↓
  LLMが上位3件の文脈をもとに回答生成
```

## 3段階パイプラインの詳細

| ステップ | 手法 | 説明 |
|----------|------|------|
| 前処理 | 温泉地フィルタ | 質問文から地名を検出 → 該当locationのチャンクのみ対象 |
| Step 1 | ハイブリッド検索 + CrossEncoder | セマンティック + BM25 → RRF統合 → CrossEncoderでスコアリング |
| Step 2 | LLM候補抽出 | LLMが各候補の関連度を0〜10で評価 → 上位5件 |
| Step 3 | 最終選択 | CE × 0.4 + LLM × 0.6 でスコア統合 → 信頼度閾値 → 上位3件 |

## Step 1: ハイブリッド検索 + CrossEncoder

```
セマンティック検索（Chroma, 10件）   BM25キーワード検索（キャッシュ済み, 10件）
          ↓                                    ↓
            RRF（Reciprocal Rank Fusion）で統合
                         ↓
         CrossEncoder（mmarco-mMiniLMv2-L12-H384-v1）でスコアリング
```

- **セマンティック検索**: ベクトル類似度で意味的に近い文書を取得
- **BM25キーワード検索**: 単語一致度で関連文書を取得（温泉地別にキャッシュ済み）
- **RRF統合**: 重み付き（semantic=0.5, keyword=0.5）の逆順位融合
- **CrossEncoder**: クエリと文書のペアを直接比較し、精密なスコアを算出

## Step 2: LLM候補抽出

CrossEncoderは汎用的な関連度を測定しますが、質問の意図を深く理解しません。
LLMに各候補文書の関連度を0〜10で評価させることで、質問の意図に合った候補を抽出します。

```
例: 質問「草津のカフェ」
  - CrossEncoder: "草津" を含む全文書を高スコアに
  - LLM: "カフェ情報" を含む文書のみを高く評価
```

候補が5件以下の場合は、LLM呼び出しをスキップして高速化します。

## Step 3: 最終選択

CrossEncoderスコア（正規化）とLLMスコア（0〜10）を統合し、最終順位を決定します。

```
final_score = 0.4 × normalize(CE_score) + 0.6 × normalize(LLM_score)
```

**信頼度フィルタ**: CrossEncoderスコアが閾値（-3.0）未満の候補は除外。
全候補が閾値以下の場合は「該当情報なし」を返します。

## 温泉地フィルタリング

質問文に含まれる温泉地名を検出し、該当チャンクのみに絞り込みます。

| 地名キーワード | フィルタ値 |
|---------------|-----------|
| 草津 | `location=kusatsu` |
| 箱根 | `location=hakone` |
| 別府 | `location=beppu` |
| 有馬 | `location=arima` |

**会話コンテキスト**: 温泉地が検出されなかった場合、直前のクエリで検出された温泉地を引き継ぎます。
例: 「有馬」→「カフェ」と続けて質問した場合、「カフェ」を有馬コンテキストで検索します。

## 実装

```python
from src.onsen_rag import OnsenRAG

rag = OnsenRAG(
    chunk_size=600,        # トークンベースチャンク
    chunk_overlap=75,      # オーバーラップ
    semantic_weight=0.5,   # セマンティック検索の重み
    initial_k=10,          # 初期検索の取得件数
    final_k=3,             # 最終採用件数
)
rag.load_from_data_folder()

result = rag.query("草津温泉のカフェは？", k=3)
print(result["result"])
```

## なぜこの構成か

- **ハイブリッド**: 固有名詞（温泉名）と意味的類似（「おすすめ」→「お勧め」）の両方に強い
- **RRF統合**: 各検索手法のランクを統合し、両方で高評価な文書を優先
- **2段階Re-ranking**: CrossEncoder（高速・汎用）+ LLM（低速・質問意図理解）の組み合わせ
- **信頼度閾値**: 質問に無関連な候補を自動排除
- **温泉地フィルタ**: 異なる温泉地のチャンクが混入する問題を防止
- **3件採用**: コンテキスト長を抑えつつ、十分な根拠を確保
